import { appendFileSync } from "node:fs";
import path from "node:path";
import type { KeyBinding, KeyEvent, ScrollBoxRenderable, TextareaRenderable } from "@opentui/core";
import { parseColor, stringToStyledText } from "@opentui/core";
import type { JSX, RefObject } from "react";
import { useKeyboard, useRenderer } from "@opentui/react";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import clipboard from "clipboardy";
import { MAX_SUGGESTION_COUNT } from "./suggestions";
import { useCompletionManager, type CompletionSuggestion } from "./completions";
import { useModalManager } from "./modalManager";
import { usePromptHistory } from "./history";
import type { ThemeDefinition } from "./theme";
import { findTheme } from "./theme";
import { useThemeManager } from "./themeManager";
import { setThemeSuggestions, setProfileSuggestions } from "./slash";
import type { SessionConfig } from "./llxprtAdapter";
import { listModels, listProviders } from "./llxprtAdapter";
import { applyConfigCommand, listAvailableProfiles, validateSessionConfig } from "./llxprtConfig";
import { useChatStore, type Role, type StreamState, type ChatLine, type ToolBlock } from "./hooks/useChatStore";
import { useInputManager } from "./hooks/useInputManager";
import { useScrollManagement } from "./hooks/useScrollManagement";
import { useStreamingResponder } from "./hooks/useStreamingResponder";

const HEADER_TEXT = "LLxprt Code - I'm here to help";
const LOGO_PATH = path.resolve(process.cwd(), "llxprt.png");
const LOGO_PX_WIDTH = 150;
const LOGO_PX_HEIGHT = 90;
const MIN_INPUT_LINES = 1;
const MAX_INPUT_LINES = 10;
const KEY_LOG_PATH = path.resolve(process.cwd(), "key-events.log");
const HEADER_LOG_PATH = path.resolve(process.cwd(), "log/header-metrics.log");

const TEXTAREA_KEY_BINDINGS: KeyBinding[] = [
  { name: "return", action: "submit" },
  { name: "return", shift: true, action: "newline" },
  { name: "return", ctrl: true, action: "newline" },
  { name: "return", meta: true, action: "newline" },
  { name: "return", alt: true, action: "newline" },
  { name: "return", super: true, action: "newline" },
  { name: "kpenter", action: "submit" },
  { name: "kpplus", action: "submit" },
  { name: "linefeed", action: "newline" }
];

interface ChatLayoutProps {
  readonly headerText: string;
  readonly lines: (ChatLine | ToolBlock)[];
  readonly scrollRef: RefObject<ScrollBoxRenderable | null>;
  readonly autoFollow: boolean;
  readonly textareaRef: RefObject<TextareaRenderable | null>;
  readonly inputLineCount: number;
  readonly enforceInputLineBounds: () => void;
  readonly handleSubmit: () => void;
  readonly statusLabel: string;
  readonly promptCount: number;
  readonly responderWordCount: number;
  readonly streamState: StreamState;
  readonly onScroll: (event: { type: string }) => void;
  readonly onMouseUp?: () => void;
  readonly suggestions: CompletionSuggestion[];
  readonly selectedSuggestion: number;
  readonly theme: ThemeDefinition;
}

interface InputAreaProps {
  readonly textareaRef: RefObject<TextareaRenderable | null>;
  readonly containerHeight: number;
  readonly textareaHeight: number;
  readonly handleSubmit: () => void;
  readonly enforceInputLineBounds: () => void;
  readonly theme: ThemeDefinition;
}

interface SuggestionPanelProps {
  readonly suggestions: CompletionSuggestion[];
  readonly selectedIndex: number;
  readonly theme: ThemeDefinition;
}

interface ScrollbackProps {
  readonly lines: (ChatLine | ToolBlock)[];
  readonly scrollRef: RefObject<ScrollBoxRenderable | null>;
  readonly autoFollow: boolean;
  readonly onScroll: (event: { type: string }) => void;
  readonly theme: ThemeDefinition;
}

interface StatusBarProps {
  readonly statusLabel: string;
  readonly promptCount: number;
  readonly responderWordCount: number;
  readonly streamState: StreamState;
  readonly theme: ThemeDefinition;
}

function HeaderBar({ text, theme }: { readonly text: string; readonly theme: ThemeDefinition }): JSX.Element {
  const renderer = useRenderer();
  const [, setMetricTick] = useState(0);
  const lastResolution = useRef<string | null>(null);

  useEffect(() => {
    const bump = () => setMetricTick((tick) => tick + 1);
    renderer.on("capabilities", bump);
    renderer.on("pixelResolution", bump);
    renderer.on("resize", bump);
    const interval = setInterval(() => {
      const current = renderer.resolution ? JSON.stringify(renderer.resolution) : null;
      if (current !== lastResolution.current) {
        lastResolution.current = current;
        setMetricTick((tick) => tick + 1);
      }
    }, 500);
    return () => {
      renderer.off("capabilities", bump);
      renderer.off("pixelResolution", bump);
      renderer.off("resize", bump);
      clearInterval(interval);
    };
  }, [renderer]);

  const caps = renderer.capabilities as { pixelResolution?: { width: number; height: number } } | null;
  const resolution = caps?.pixelResolution ?? renderer.resolution ?? null;
  const pxPerCellX = resolution && renderer.terminalWidth > 0 ? resolution.width / renderer.terminalWidth : null;
  const pxPerCellY = resolution && renderer.terminalHeight > 0 ? resolution.height / renderer.terminalHeight : null;
  const desiredCellHeight = 2;
  const scaleFactor = 0.9; // modest shrink to keep it inside the border
  const fallbackPxPerCellX = 9;
  const fallbackPxPerCellY = 20;
  const scaledPixelHeight = Math.round(
    pxPerCellY != null
      ? Math.min(LOGO_PX_HEIGHT * scaleFactor, pxPerCellY * desiredCellHeight * scaleFactor)
      : LOGO_PX_HEIGHT * scaleFactor
  );
  const scaledPixelWidth = Math.max(1, Math.round((scaledPixelHeight * LOGO_PX_WIDTH) / LOGO_PX_HEIGHT));
  const effPxPerCellX = pxPerCellX ?? fallbackPxPerCellX;
  const effPxPerCellY = pxPerCellY ?? fallbackPxPerCellY;
  const logoWidthCells = Math.max(1, Math.ceil(scaledPixelWidth / effPxPerCellX));
  const logoHeightCells = Math.max(1, Math.ceil(scaledPixelHeight / effPxPerCellY));
  const headerHeight = Math.max(logoHeightCells + 1, 3);

  useEffect(() => {
    const logLine = JSON.stringify(
      {
        pixelResolution: resolution ?? null,
        terminal: { cols: renderer.terminalWidth, rows: renderer.terminalHeight },
        pxPerCellX: pxPerCellX ?? null,
        pxPerCellY: pxPerCellY ?? null,
        logo: {
          pixel: { width: scaledPixelWidth, height: scaledPixelHeight },
          cells: { width: logoWidthCells, height: logoHeightCells }
        },
        headerHeight
      },
      null,
      0
    );
    appendFileSync(HEADER_LOG_PATH, `${logLine}\n`, "utf8");
  }, [resolution, pxPerCellX, pxPerCellY, scaledPixelWidth, scaledPixelHeight, logoWidthCells, logoHeightCells, headerHeight, renderer.terminalWidth, renderer.terminalHeight]);

  return (
    <box
      style={{
        border: true,
        height: headerHeight,
        minHeight: headerHeight,
        maxHeight: headerHeight,
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0,
        borderColor: theme.colors.panel.border,
        backgroundColor: theme.colors.panel.headerBg ?? theme.colors.panel.bg,
        alignItems: "center",
        flexDirection: "row",
        gap: 0,
        justifyContent: "flex-start"
      }}
    >
      <image
        src={LOGO_PATH}
        alt="LLxprt Code"
        width={logoWidthCells}
        height={logoHeightCells}
        pixelWidth={scaledPixelWidth}
        pixelHeight={scaledPixelHeight}
        style={{ marginRight: 1 }}
      />
      <text
        fg={theme.colors.panel.headerFg ?? theme.colors.text.primary}
        style={{ marginLeft: 1, alignSelf: "center" }}
      >
        {text}
      </text>
    </box>
  );
}

function ScrollbackView(props: ScrollbackProps): JSX.Element {
  return (
    <scrollbox
      ref={props.scrollRef}
      style={{
        flexGrow: 1,
        border: true,
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0,
        overflow: "hidden",
        borderColor: props.theme.colors.panel.border,
        backgroundColor: props.theme.colors.panel.bg
      }}
      contentOptions={{ paddingLeft: 2, paddingRight: 2 }}
      scrollX={false}
      stickyScroll={props.autoFollow}
      stickyStart="bottom"
      scrollY
      onMouse={props.onScroll}
      focused
      >
        <box flexDirection="column" style={{ gap: 0, width: "100%" }}>
          {props.lines.map((entry) =>
            entry.kind === "line" ? renderChatLine(entry, props.theme) : renderToolBlock(entry, props.theme)
          )}
        </box>
      </scrollbox>
  );
}

function InputArea(props: InputAreaProps): JSX.Element {
  const placeholderText = useMemo(() => {
    const base = stringToStyledText("Type a thought, then submit with Enter");
    const fg = parseColor(props.theme.colors.input.placeholder);
    return { ...base, chunks: base.chunks.map((chunk) => ({ ...chunk, fg })) };
  }, [props.theme.colors.input.placeholder]);

  return (
    <box
      style={{
        height: props.containerHeight,
        minHeight: MIN_INPUT_LINES + 2,
        maxHeight: MAX_INPUT_LINES + 2,
        border: true,
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0,
        flexDirection: "column",
        gap: 0,
        borderColor: props.theme.colors.panel.border,
        backgroundColor: props.theme.colors.panel.bg
      }}
    >
      <textarea
        ref={props.textareaRef}
        focused
        placeholder={placeholderText}
        keyBindings={TEXTAREA_KEY_BINDINGS}
        onSubmit={props.handleSubmit}
        onContentChange={props.enforceInputLineBounds}
        onCursorChange={props.enforceInputLineBounds}
        wrapMode="word"
        style={{
          height: props.textareaHeight,
          minHeight: props.textareaHeight,
          maxHeight: props.textareaHeight,
          width: "100%",
          paddingLeft: 1,
          paddingRight: 1,
          paddingTop: 0,
          paddingBottom: 0,
          fg: props.theme.colors.input.fg,
          bg: props.theme.colors.input.bg,
          borderColor: props.theme.colors.input.border
        }}
        textColor={props.theme.colors.input.fg}
        focusedTextColor={props.theme.colors.input.fg}
        backgroundColor={props.theme.colors.input.bg}
        focusedBackgroundColor={props.theme.colors.input.bg}
      />
    </box>
  );
}

function SuggestionPanel(props: SuggestionPanelProps): JSX.Element | null {
  if (props.suggestions.length === 0) {
    return null;
  }

  const pageSize = MAX_SUGGESTION_COUNT;
  const totalPages = Math.max(1, Math.ceil(props.suggestions.length / pageSize));
  const pageIndex = Math.floor(props.selectedIndex / pageSize);
  const pageStart = pageIndex * pageSize;
  const pageItems = props.suggestions.slice(pageStart, pageStart + pageSize);
  const maxLabel = pageItems.reduce(
    (max, item) => Math.max(max, item.value.length + (item.mode === "slash" ? 1 : 0)),
    0
  );
  const indicatorNeeded = props.suggestions.length > pageSize;
  const height = pageItems.length + (indicatorNeeded ? 1 : 0);

  return (
    <box
      style={{
        height,
        minHeight: height,
        maxHeight: height,
        paddingLeft: 1,
        paddingRight: 1,
        paddingTop: 0,
        paddingBottom: 0,
        flexDirection: "column"
      }}
    >
      {pageItems.map((item, index) =>
        renderSuggestionRow(item, pageStart + index, props.selectedIndex, maxLabel, props.theme)
      )}
      {indicatorNeeded ? <text fg={props.theme.colors.text.muted}>{`▼ page ${pageIndex + 1}/${totalPages} ▲`}</text> : null}
    </box>
  );
}

function renderSuggestionRow(
  item: CompletionSuggestion,
  globalIndex: number,
  selectedIndex: number,
  maxLabel: number,
  theme: ThemeDefinition
): JSX.Element {
  const isSelected = globalIndex === selectedIndex;
  const prefix = item.mode === "slash" && item.displayPrefix !== false ? "/" : "";
  const label = `${prefix}${item.value}`.padEnd(maxLabel + 1, " ");
  const description = item.description ? ` ${item.description}` : "";
  const rowText = `${label}${description}`;
  return (
    <text
      key={`suggestion-${globalIndex}`}
      bg={isSelected ? theme.colors.accent.primary : undefined}
      fg={isSelected ? theme.colors.selection.fg : theme.colors.text.primary}
    >
      {rowText}
    </text>
  );
}

function StatusBar(props: StatusBarProps): JSX.Element {
  return (
    <box
      style={{
        minHeight: 1,
        maxHeight: 3,
        paddingLeft: 1,
        paddingRight: 1,
        flexDirection: "row",
        justifyContent: "space-between",
        backgroundColor: props.theme.colors.panel.bg
      }}
    >
      <text fg={props.theme.colors.text.primary}>{props.statusLabel}</text>
      <text fg={props.theme.colors.text.primary}>
        {`prompts: ${props.promptCount} | words: ${props.responderWordCount} | ${props.streamState}`}
      </text>
    </box>
  );
}

function ChatLayout(props: ChatLayoutProps): JSX.Element {
  const visibleInputLines = Math.min(MAX_INPUT_LINES, clampInputLines(props.inputLineCount));
  const containerHeight = Math.min(MAX_INPUT_LINES + 2, Math.max(MIN_INPUT_LINES + 2, visibleInputLines + 2));
  const textareaHeight = Math.max(3, containerHeight - 2);

  return (
    <box
      flexDirection="column"
      style={{ width: "100%", height: "100%", padding: 1, gap: 1, backgroundColor: props.theme.colors.background }}
      onMouseUp={props.onMouseUp}
    >
      <HeaderBar text={props.headerText} theme={props.theme} />
      <ScrollbackView
        lines={props.lines}
        scrollRef={props.scrollRef}
        autoFollow={props.autoFollow}
        onScroll={props.onScroll}
        theme={props.theme}
      />
      <InputArea
        textareaRef={props.textareaRef}
        containerHeight={containerHeight}
        textareaHeight={textareaHeight}
        handleSubmit={props.handleSubmit}
        enforceInputLineBounds={props.enforceInputLineBounds}
        theme={props.theme}
      />
      <SuggestionPanel suggestions={props.suggestions} selectedIndex={props.selectedSuggestion} theme={props.theme} />
      <StatusBar
        statusLabel={props.statusLabel}
        promptCount={props.promptCount}
        responderWordCount={props.responderWordCount}
        streamState={props.streamState}
        theme={props.theme}
      />
    </box>
  );
}

function renderChatLine(line: ChatLine, theme: ThemeDefinition): JSX.Element {
  const color = roleColor(line.role, theme);
  return (
    <text key={line.id} fg={color}>
      [{line.role}] {line.text}
    </text>
  );
}

function roleColor(role: Role, theme: ThemeDefinition): string {
  if (role === "user") {
    return theme.colors.text.user;
  }
  if (role === "thinking") {
    return theme.colors.text.thinking;
  }
  return theme.colors.text.responder;
}

function renderToolBlock(block: ToolBlock, theme: ThemeDefinition): JSX.Element {
  const content = block.scrollable === true ? (
    <scrollbox
      style={{
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        height: Math.min(block.lines.length + 1, block.maxHeight ?? block.lines.length + 1),
        maxHeight: block.maxHeight,
        overflow: "hidden"
      }}
      contentOptions={{ paddingLeft: 0, paddingRight: 0 }}
      scrollY
      scrollX={false}
    >
      <box flexDirection="column" style={{ gap: 0, width: "100%", paddingLeft: 0, paddingRight: 0 }}>
        {block.lines.map((line, index) => (
          <text key={`${block.id}-line-${index}`} fg={theme.colors.text.tool}>
            {line}
          </text>
        ))}
      </box>
    </scrollbox>
  ) : (
    block.lines.map((line, index) => (
      <text key={`${block.id}-line-${index}`} fg={theme.colors.text.tool}>
        {line}
      </text>
    ))
  );

  return (
    <box
      key={block.id}
      border
      style={{
        padding: 1,
        marginTop: 0,
        marginBottom: 0,
        width: "100%",
        flexDirection: "column",
        gap: 0,
        borderStyle: block.isBatch ? "rounded" : "single",
        borderColor: theme.colors.panel.border,
        backgroundColor: theme.colors.panel.bg,
        overflow: "hidden"
      }}
    >
      {content}
      {block.streaming === true ? (
        <text fg={theme.colors.text.muted} key={`${block.id}-streaming`}>
          ...streaming...
        </text>
      ) : null}
    </box>
  );
}

function isEnterKey(key: KeyEvent): boolean {
  return (
    key.name === "return" ||
    key.name === "enter" ||
    key.name === "kpenter" ||
    key.name === "kpplus" ||
    key.code === "[57415u" ||
    key.code === "[57414u" ||
    key.sequence === "\r" ||
      key.sequence === "\n"
  );
}
function useEnterSubmit(onSubmit: () => void, isBlocked: boolean): void {
  useKeyboard((key) => {
    const isEnterLike = isEnterKey(key);
    if (isEnterLike) {
      logEnterKey(key);
    }
    if (isEnterLike && !isBlocked) {
      const hasModifier = key.shift === true || key.ctrl === true || key.meta === true || key.option === true || key.super === true;
      if (!hasModifier) {
        key.preventDefault();
        onSubmit();
      }
    }
  });
}
function logEnterKey(key: KeyEvent): void {
  try {
    const line = `${new Date().toISOString()}|${key.name}|${key.code ?? ""}|${JSON.stringify(key)}\n`;
    appendFileSync(KEY_LOG_PATH, line, "utf8");
  } catch {
    // ignore logging errors
  }
}
function logAnyKey(key: KeyEvent): void {
  try {
    const line = `${new Date().toISOString()}|${key.name}|${key.code ?? ""}|${key.sequence}|${key.raw}|${
      key.source
    }\n`;
    appendFileSync(KEY_LOG_PATH, line, "utf8");
  } catch {
    // ignore logging errors
  }
}

function useFocusAndMount(textareaRef: RefObject<TextareaRenderable | null>, mountedRef: RefObject<boolean>): void {
  useEffect(() => {
    if (textareaRef.current != null) {
      textareaRef.current.focus();
    }
    return () => {
      mountedRef.current = false;
    };
  }, [mountedRef, textareaRef]);
}

function useKeyPressLogging(): void {
  useKeyboard((key) => {
    if (key.eventType === "press") {
      logAnyKey(key);
    }
  });
}

function useSuggestionKeybindings(
  suggestionCount: number,
  moveSelection: (delta: number) => void,
  handleTabComplete: () => void,
  cancelStreaming: () => void,
  clearInput: () => Promise<void>,
  isStreaming: () => boolean
): void {
  const hasSuggestions = suggestionCount > 0;
  useKeyboard((key) => {
    if (hasSuggestions && key.name === "down") {
      key.preventDefault();
      moveSelection(1);
    } else if (hasSuggestions && key.name === "up") {
      key.preventDefault();
      moveSelection(-1);
    } else if (hasSuggestions && key.name === "tab") {
      key.preventDefault();
      handleTabComplete();
    } else if (key.name === "escape") {
      if (isStreaming()) {
        cancelStreaming();
      } else {
        void clearInput();
      }
    }
  });
}

function buildStatusLabel(streamState: StreamState, autoFollow: boolean): string {
  const streamingPart = streamState === "streaming" ? "streaming" : "waiting";
  const scrollPart = autoFollow ? "follow" : "scroll lock";
  return `${streamingPart} | ${scrollPart}`;
}

function useLineIdGenerator(): () => string {
  const nextLineId = useRef(0);
  return useCallback((): string => {
    nextLineId.current += 1;
    return `line-${nextLineId.current}`;
  }, []);
}

export function App(): JSX.Element {
  const scrollRef = useRef<ScrollBoxRenderable | null>(null);
  const textareaRef = useRef<TextareaRenderable | null>(null);
  const streamRunId = useRef(0);
  const mountedRef = useRef(true);
  const abortRef = useRef<AbortController | null>(null);
  const [sessionConfig, setSessionConfig] = useState<SessionConfig>({ provider: "openai" });
  const { themes, theme, setThemeBySlug } = useThemeManager();
  const renderer = useRenderer();
  const { suggestions, selectedIndex, refresh: refreshCompletion, clear: clearCompletion, moveSelection, applySelection } =
    useCompletionManager(textareaRef);
  const { record: recordHistory, handleHistoryKey } = usePromptHistory(textareaRef);

  useFocusAndMount(textareaRef, mountedRef);

  const makeLineId = useLineIdGenerator();

  const {
    lines,
    appendLines,
    appendToolBlock,
    promptCount,
    setPromptCount,
    responderWordCount,
    setResponderWordCount,
    streamState,
    setStreamState
  } = useChatStore(makeLineId);

  useEffect(() => {
    setThemeSuggestions(themes.map((entry) => ({ slug: entry.slug, name: entry.name })));
  }, [themes]);

  useEffect(() => {
    listAvailableProfiles()
      .then((profiles) => setProfileSuggestions(profiles))
      .catch(() => {
        return;
      });
  }, []);

  const fetchModelItems = useCallback(async () => {
    const missing = validateSessionConfig(sessionConfig, { requireModel: false });
    if (missing.length > 0) {
      return { items: [], messages: missing };
    }
    try {
      const models = await listModels(sessionConfig);
      const items = models.map((model) => ({ id: model.id, label: model.name || model.id }));
      return { items };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return { items: [], messages: [`Failed to load models: ${message}`] };
    }
  }, [sessionConfig]);

  const fetchProviderItems = useCallback(async () => {
    try {
      const providers = await Promise.resolve(listProviders());
      const items = providers.map((p) => ({ id: p.id, label: p.label }));
      return { items };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return { items: [], messages: [`Failed to load providers: ${message}`] };
    }
  }, []);

  const { modalOpen, modalElement, handleCommand: handleModalCommand } = useModalManager(
    appendLines,
    () => {
      if (textareaRef.current != null) {
        textareaRef.current.focus();
      }
    },
    themes,
    theme,
    (next) => setThemeBySlug(next.slug),
    sessionConfig,
    setSessionConfig,
    fetchModelItems,
    fetchProviderItems
  );

  const { autoFollow, setAutoFollow, handleContentChange, handleMouseScroll } = useScrollManagement(scrollRef);

  useEffect(() => {
    handleContentChange();
  }, [handleContentChange, lines.length]);

  const startStreamingResponder = useStreamingResponder(
    appendLines,
    appendToolBlock,
    setResponderWordCount,
    setStreamState,
    streamRunId,
    mountedRef,
    abortRef
  );

  const applyTheme = useCallback(
    (key: string) => {
      const match = findTheme(themes, key);
      if (!match) {
        appendLines("responder", [`Theme not found: ${key}`]);
        return;
      }
      setThemeBySlug(match.slug);
      appendLines("responder", [`Theme set to ${match.name}`]);
    },
    [appendLines, setThemeBySlug, themes]
  );

  const handleCommand = useCallback(
    async (command: string) => {
      const configResult = await applyConfigCommand(command, sessionConfig);
      if (configResult.handled) {
        setSessionConfig(configResult.nextConfig);
        if (configResult.messages.length > 0) {
          appendLines("responder", configResult.messages);
        }
        return true;
      }
      if (command.startsWith("/theme")) {
        const parts = command.trim().split(/\s+/);
        if (parts.length === 1) {
          return handleModalCommand("/theme");
        }
        const target = parts.slice(1).join(" ");
        applyTheme(target);
        return true;
      }
      return handleModalCommand(command);
    },
    [appendLines, applyTheme, handleModalCommand, sessionConfig]
  );

  const cancelStreaming = useCallback(() => {
    streamRunId.current += 1;
    if (abortRef.current != null) {
      abortRef.current.abort();
    }
    setStreamState("idle");
  }, [setStreamState]);

  const { inputLineCount, enforceInputLineBounds, handleSubmit, handleTabComplete } = useInputManager(
    textareaRef,
    appendLines,
    setPromptCount,
    setAutoFollow,
    (prompt) => startStreamingResponder(prompt, sessionConfig),
    refreshCompletion,
    clearCompletion,
    applySelection,
    handleCommand,
    recordHistory
  );

  const statusLabel = useMemo(() => buildStatusLabel(streamState, autoFollow), [autoFollow, streamState]);
  const handleMouseUp = useSelectionClipboard(renderer);

  const handleSubmitWrapped = useCallback(() => {
    void handleSubmit();
  }, [handleSubmit]);

  useEnterSubmit(() => void handleSubmit(), modalOpen);
  useKeyPressLogging();
  useSuggestionKeybindings(
    modalOpen ? 0 : suggestions.length,
    moveSelection,
    handleTabComplete,
    cancelStreaming,
    () => {
      if (textareaRef.current != null) {
        textareaRef.current.clear();
      }
      enforceInputLineBounds();
      return Promise.resolve();
    },
    () => streamState === "streaming"
  );
  useKeyboard((key) => {
    if (modalOpen || suggestions.length > 0 || key.eventType !== "press") {
      return;
    }
    if (key.name === "up" || key.name === "down") {
      const handled = handleHistoryKey(key.name);
      if (handled) {
        key.preventDefault();
      }
    }
  });

  return (
    <>
      <ChatLayout
        headerText={HEADER_TEXT}
        lines={lines}
        scrollRef={scrollRef}
        autoFollow={autoFollow}
        textareaRef={textareaRef}
        inputLineCount={inputLineCount}
        enforceInputLineBounds={enforceInputLineBounds}
        handleSubmit={handleSubmitWrapped}
        statusLabel={statusLabel}
        promptCount={promptCount}
        responderWordCount={responderWordCount}
        streamState={streamState}
        onScroll={handleMouseScroll}
        onMouseUp={handleMouseUp}
        suggestions={suggestions}
        selectedSuggestion={selectedIndex}
        theme={theme}
      />
      {modalElement}
    </>
  );
}

function clampInputLines(value: number): number {
  return Math.min(MAX_INPUT_LINES, Math.max(MIN_INPUT_LINES, value));
}

function useSelectionClipboard(renderer: unknown): () => void {
  return useCallback(() => {
    const rendererWithSelection = renderer as { getSelection?: () => { getSelectedText?: () => string | null } | null };
    if (rendererWithSelection.getSelection == null) {
      return;
    }
    const selection = rendererWithSelection.getSelection();
    if (selection?.getSelectedText == null) {
      return;
    }
    const text = selection.getSelectedText() ?? "";
    if (text.length === 0) {
      return;
    }
    const osc = buildOsc52(text);
    try {
      const rendererWithWrite = renderer as { writeOut?: (chunk: string) => void };
      if (rendererWithWrite.writeOut != null) {
        rendererWithWrite.writeOut(osc);
      }
    } catch {
      // ignore renderer write failures
    }
    void clipboard.write(text).catch(() => {
      return;
    });
  }, [renderer]);
}

function buildOsc52(text: string): string {
  const base64 = Buffer.from(text).toString("base64");
  const osc52 = `\u001b]52;c;${base64}\u0007`;
  if (process.env.TMUX) {
    return `\u001bPtmux;\u001b${osc52}\u001b\\`;
  }
  return osc52;
}

